---
title: "Estimates of Steelhead in Dungeness River"
subtitle: "Using Sonar"
author:
  - Kevin See:
      email: Kevin.See@dfw.wa.gov
      institute: [wdfw]
      correspondence: true
  - Bethany Craig:
      email: Bethany.Craig@dfw.wa.gov
      institute: [wdfw]
      correspondence: false
institute:
  - wdfw: Washington Department of Fish & Wildlife
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
    wdfwTemplates::wdfw_html_format2:
      fig_caption: yes
      fig_height: 4
      fig_width: 6
      toc: yes
      toc_depth: 3
      toc_float:
        collapsed: yes
        smooth_scroll: yes
      pandoc_args:
      - --lua-filter=../templates/scholarly-metadata.lua
      - --lua-filter=../templates/author-info-blocks.lua
      - --lua-filter=../templates/pagebreak.lua
    bookdown::pdf_document2:
      fig_caption: yes
      fig_height: 5
      fig_width: 6
      toc: yes
      includes:
        in_header: ../templates/header_WDFW.tex
      pandoc_args:
      - --lua-filter=../templates/scholarly-metadata.lua
      - --lua-filter=../templates/author-info-blocks2.lua
      - --lua-filter=../templates/pagebreak.lua
    bookdown::word_document2:
      fig_caption: yes
      fig_height: 4
      fig_width: 6
      toc: yes
      reference_docx: "../templates/ReportTemplate.docx" # Insert path for the DOCX file
      pandoc_args:
      - --lua-filter=../templates/scholarly-metadata.lua
      - --lua-filter=../templates/author-info-blocks.lua
      - --lua-filter=../templates/pagebreak.lua
bibliography:
  # - AUC.bib
  - references.bib
csl: "../templates/american-fisheries-society.csl" # Insert path for the bib-style
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  comment = "#>",
  fig.path = "../figures/",
  dpi = 300
)
```

```{r packages}
# load these packages
library(tidyverse)
library(here)
library(magrittr)
library(janitor)
library(lubridate)
library(readxl)
library(splines)
library(mgcv)
library(ggfortify)
library(ggpubr)
library(scales)
library(colorspace)
library(kableExtra)

theme_set(theme_bw())

# knitr options
options(knitr.kable.NA = '-')

# when knitting to Word, use this
# what kind of document is being created?
doc.type <- knitr::opts_knit$get('rmarkdown.pandoc.to')

if(doc.type == 'docx') {
  options(knitr.table.format = "pandoc")
}

```


```{r read-data}
sonar_raw <- read_csv(here("analysis/data/raw_data",
                           "2019 sonar.csv")) %>%
  mutate(across(Hour,
                hms)) %>%
  bind_rows(read_csv(here("analysis/data/raw_data",
                          "2020 sonar.csv")) %>%
              mutate(across(Hour,
                            ~ str_pad(.,
                                      width = 5,
                                      side = "left",
                                      pad = "0"))) %>%
              mutate(across(Hour,
                            hm)) %>%
              rename(comments = `Comments/Notes`) %>%
              clean_names("upper_camel")) %>%
  bind_rows(read_csv(here("analysis/data/raw_data",
                          "2021 sonar.csv")) %>%
              mutate(across(Hour,
                            ~ hm(paste(str_sub(., 1,2),
                                       str_sub(., 3, 4),
                                       sep = ":")))) %>%
              rename(comments = `Comments/Notes`) %>%
              clean_names("upper_camel")) %>%
  bind_rows(read_csv(here("analysis/data/raw_data",
                          "2022 sonar.csv")) %>%
              mutate(across(
                Hour,
                ~ str_remove(., ":")
              )) |> 
              mutate(across(
                Hour,
                ~ hm(paste(str_sub(., 1,2),
                           str_sub(., 3,4),
                           sep = ":")))) %>%
              clean_names("upper_camel")) %>%
  filter(!is.na(Year)) %>%
  mutate(across(Date,
                mdy)) %>%
  mutate(across(DataReviewed,
                ~ recode(.,
                         "No Data" = "No data"))) %>%
  mutate(across(DataRecorded,
                ~ recode(.,
                         "No Data" = "No data",
                         "full" = "Full"))) %>%
  mutate(across(Time,
                ~ recode(.,
                         "No Data" = "No data",
                         "no fish" = "No fish",
                         "No Fish" = "No fish")),
         Time = if_else(str_detect(Comments, "No data"),
                        "No data",
                        Time),
         across(Direction,
                ~ recode(.,
                         "Downstream" = "downstream",
                         "Upstream" = "upstream"))) %>%
  mutate(across(DataRecorded,
                ~ if_else(. == "None" & (Time == "No data" | is.na(Time)),
                          "No data",
                          .)),
         across(DataReviewed,
                ~ if_else(DataRecorded == "No data" & str_detect(DataReviewed, "30"),
                          "No data",
                          .))) %>%
  clean_names() %>%
  mutate(date_time = date + hour) %>%
  arrange(date_time) %>%
  # drop any detections after June 1
  filter(month(date) < 6)

# drop a couple records because they don't match
# one upstream and one downstream fish recorded during the 2nd half hour,
# but no data in the first half hour, at all
sonar_raw %<>%
  filter(!(date == ymd(20200322) &
             hour == "30M 0S"))

sonar_raw %<>%
  filter(!(date == ymd(20200301) &
             (str_detect(hour, "^0S") |
                str_detect(hour, "^30M") |
                str_detect(hour, "^1H"))))

# fix one row where the time doesn't match the hour
sonar_raw %<>%
  mutate(across(
    time,
    ~ if_else(date == ymd(20210227) & hour(hour) == 22,
              str_replace(., "^23:", "22:"),
              .)))


# add a couple missing row (assuming no fish detected)
sonar_raw %<>%
  bind_rows(sonar_raw %>%
              filter(date == ymd(20190320),
                     str_detect(hour, "15H")) %>%
              mutate(hour = hour + minutes(30),
                     date_time = date + hour,
                     data_reviewed = "Second 30",
                     across(c(direction),
                            ~ NA),
                     across(c(length:confidence),
                            ~ NA_real_))) %>%
  bind_rows(sonar_raw |> 
              filter(date==ymd(20190420), 
                     str_detect(hour, "23H")) |> 
              mutate(hour = hour - minutes(30),
                     date_time = date + hour,
                     data_reviewed = "First 30")) %>%
  arrange(date_time)



# correct some columns in one row
sonar_raw %>%
  filter(!(date == ymd(20200218) &
             data_recorded == "No data" &
             data_reviewed == "No data")) %>%
  bind_rows(
    sonar_raw %>%
      filter(date == ymd(20200218),
             data_recorded == "No data",
             data_reviewed == "No data") %>%
      mutate(data_recorded = "Full",
             data_reviewed = "Second 30")) %>%
  arrange(date_time) -> sonar_raw

# fix a couple times
sonar_raw <- sonar_raw |> 
  mutate(n_colon = str_count(time, ":")) |> 
  # filter(n_colon == 1) |> 
  mutate(time = if_else(n_colon == 1 & !is.na(time),
                        paste0(time, ":00"),
                        time)) |> 
  select(-n_colon)



# pull out records of fish detections
sonar_fish <- sonar_raw %>%
  filter(data_recorded != "Partial",
         confidence == 1) %>%
  filter(!is.na(frame)) %>%
  mutate(sthd_length = if_else(length > 67, T, F)) %>%
  mutate(notes = time,
         across(time,
                hms))

#--------------------------------------------------
# which hours do we want to group together?
#--------------------------------------------------
# 6 hour blocks
hrs_fct_grp <- rep(1:4, each = 6) |>
  set_names(0:23)

# set up tibble containing all half hour periods that sonar was operating
half_hr_periods <- sonar_raw %>%
  group_by(year) %>%
  summarize(across(date,
                   list(min = ~ min(., na.rm = T),
                        max = ~ max(., na.rm = T)),
                   .names = "{.fn}"),
            .groups = "drop") %>%
  mutate(across(c(min,
                  max),
                as.POSIXct),
         across(min,
                ~ floor_date(., unit = "days")),
         across(max,
                ~ ceiling_date(., unit = "days")),
         across(max,
                ~ . + dhours(23.5))) |> 
  mutate(date_time = map2(min,
                          max,
                          .f = function(x, y) seq(x, y, by = 30*60))) %>%
  select(-min, -max) %>%
  unnest(date_time) %>%
  mutate(across(date_time,
                ~ ymd_hms(as.character(.), tz = "America/Los_Angeles"))) |> 
  mutate(date = floor_date(date_time,
                           unit = "day"),
         hour = floor_date(date_time,
                           unit = "hour"),
         time = difftime(date_time, date,
                         units = "mins"),
         hour = difftime(hour, date,
                         units = "mins"),
         across(c(time,
                  hour),
                as.period)) %>%
  left_join(sonar_raw %>%
              mutate(data_reviewed = if_else(data_recorded %in% c("None", "Partial", "Poor Image"),
                                             "Not reviewed",
                                             data_reviewed)) %>%
              mutate(date_time = date + hour,
                     across(date_time,
                            ~ ymd_hms(as.character(.), tz = "America/Los_Angeles"))) |> 
              select(year, date_time,
                     data_recorded,
                     data_reviewed) %>%
              distinct() %>%
              filter(data_recorded %in% c("Full")) |> 
              mutate(reviewed = if_else(data_reviewed == "Not reviewed",
                                        FALSE,
                                        TRUE))) %>%
  mutate(
    across(
      reviewed,
      ~ replace_na(.,
                   FALSE)
    )) %>%
  # mutate(reviewed = if_else(!is.na(data_reviewed) & data_reviewed == "No data",
  #                           F, reviewed)) %>%
  mutate(data_recorded = if_else(is.na(data_recorded) &
                                   lag(data_recorded == "Full") &
                                   lag(data_reviewed == "First 30"),
                                 "Full",
                                 data_recorded)) %>%
  mutate(operational = if_else(reviewed |
                                 data_recorded == "Full",
                               T, F)) %>%
  mutate(hr_fct = hrs_fct_grp[as.character(hour(date_time))]) %>%
  relocate(hour, hr_fct, .after = "time") %>%
  # fix one data_reviewed entry
  mutate(data_reviewed = if_else(str_detect(time, "30M") & 
                                   data_recorded == "Full" &
                                   data_reviewed == "First 30",
                                 "Second 30",
                                 data_reviewed)) %>%
  # fix some NAs in data review
  mutate(data_reviewed = if_else(operational &
                                   data_recorded == "Full" &
                                   is.na(data_reviewed),
                                 "Not reviewed",
                                 data_reviewed)) %>%
  mutate(across(
    operational,
    ~ replace_na(., F)
  )) |> 
  mutate(across(data_recorded,
                ~ replace_na(., "No data")),
         across(data_reviewed,
                ~ replace_na(., "No data")),
         across(data_reviewed,
                ~ if_else(data_recorded == "No data" & . == "Not reviewed",
                          "No data",
                          .)))

# which hours had the 2nd 30 min reviewed?
full_hrs <- half_hr_periods %>%
  filter(data_reviewed %in% c("First 30",
                              "Second 30")) %>%
  group_by(date, hour) %>%
  mutate(n_pers = n(),
         n_first = sum(str_detect(data_reviewed, "First")),
         n_second = sum(str_detect(data_reviewed, "Second"))) %>%
  # filter(year == 2022) |>
  # as.data.frame() |> head(10)
  filter(n_pers == 2,
         n_first == 1,
         n_second == 1) %>%
  arrange(date_time) %>%
  ungroup() %>%
  select(all_of(names(half_hr_periods)))

# add column indicating if full hour was reviewed
half_hr_periods <- half_hr_periods %>%
  left_join(full_hrs |> 
              mutate(full_hr = T)) |> 
  mutate(across(
    full_hr,
    ~ replace_na(., F)
  ))

# consolidate into hour periods
hr_periods <- half_hr_periods |> 
  reframe(across(date_time,
                   ~ floor_date(., 
                                unit = "hours")),
            across(c(data_recorded,
                     data_reviewed,
                     reviewed,
                     operational,
                     full_hr),
                   ~ paste(., collapse = "_")),
          .by = c(year, date, hour, hr_fct)) |>
  distinct() |> 
  relocate(date_time,
           .after = "hour") |> 
  mutate(
    across(
      data_recorded,
      ~ recode(.,
               "Full_Full" = "Full",
               "Full_No data" = "Partial",
               "No data_Full" = "Partial",
               "No data_No data" = "No data")),
    across(
      data_reviewed,
      ~ recode(.,
               "First 30_Not reviewed" = "First 30 Only",
               "First 30_Second 30" = "Full Hour",
               "No data_No data" = "No data",
               "Not reviewed_No data" = "No data",
               "No data_Second 30" = "Second 30 Only")),
    across(
      reviewed,
      ~ if_else(str_detect(., "TRUE"),
                T,
                F)),
    across(operational,
           ~ if_else(data_recorded == "No data",
                     F, T)),
    across(full_hr,
           ~ if_else(. == "TRUE_TRUE",
                     T, F))
  )

# # add counts of upstream, downstream and net large fish to hr_periods
# ts_df <- hr_periods %>%
#   left_join(sonar_fish %>%
#               filter(confidence == 1) %>%
#               group_by(year,
#                        date,
#                        time = hour,
#                        sthd_length) %>%
#               count(direction) %>%
#               ungroup() %>%
#               filter(direction %in% c("upstream",
#                                       "downstream")) %>%
#               mutate(across(direction,
#                             ~ recode(.,
#                                      "upstream" = "up",
#                                      "downstream" = "down")),
#                      across(sthd_length,
#                             as.character),
#                      across(sthd_length,
#                             ~ recode(.,
#                                      "TRUE" = "sthd",
#                                      "FALSE" = "small"))) %>%
#               pivot_wider(names_from = c(direction, sthd_length),
#                           values_from = n,
#                           values_fill = 0)) %>%
#   mutate(across(c(starts_with("up"), 
#                   starts_with("down")),
#                 ~ if_else(is.na(.) & reviewed, as.integer(0), .))) %>%
#   # mutate(across(
#   #   sthd_length,
#   #   ~ if_else(is.na(.) & reviewed, T, .)
#   # )) %>%
#   # mutate(net = up - down)
#   mutate(net_sthd = up_sthd - down_sthd,
#          net_small = up_small - down_small)
# 
# ts_long <- ts_df %>%
#   pivot_longer(c(starts_with("up"),
#                  starts_with("down"),
#                  starts_with("net")),
#                values_to = "n_fish") %>%
#   mutate(direction = str_split(name, "_", simplify = T)[,1],
#          size = str_split(name, "_", simplify = T)[,2]) %>%
#   select(-name) %>%
#   relocate(n_fish, 
#            .after = last_col())
# 
# # split data by direction, steelhead length (and also missing data)
# analysis_grps <- ts_long |> 
#   filter(direction != "net") |> 
#   mutate(missing = if_else(is.na(n_fish), T, F)) |> 
#   nest(data = -c(direction,
#                  size,
#                  missing)) |> 
#   arrange(missing,
#           size,
#           direction)

```

```{r spp-comp-data}
#--------------------------------------------------
# species composition data
#--------------------------------------------------
spp_comp_2021 <- read_excel(here("analysis/data/raw_data",
                                 "Species Comp ALL.xlsx"),
                            "2021 lengths") %>%
  clean_names() %>%
  mutate(spp = recode(species,
                      "Resident rainbow" = "Resident RB")) %>%
  rename(date = survey_date,
         rml = rm_lower,
         rmu = rm_upper,
         age = scale_age,
         mark_status = mark,
         gear = survey_type) |> 
  mutate(fork_length_mm = fork_length * 10,
         poh_length_mm = poh * 10)

spp_comp_2022 <- read_excel(here("analysis/data/raw_data",
                                 "Dungeness_sppcomp_data_2022_FINAL.xlsx"),
                            "BullTrout",
                            skip = 2) %>%
  mutate(across(
    contains("mm"),
    as.numeric
  )) |> 
  bind_rows(read_excel(here("analysis/data/raw_data",
                            "Dungeness_sppcomp_data_2022_FINAL.xlsx"),
                       "Steelhead",
                       skip = 2) |> 
              mutate(across(
                contains("mm"),
                as.numeric
              ))) %>%
  bind_rows(read_excel(here("analysis/data/raw_data",
                            "Dungeness_sppcomp_data_2022_FINAL.xlsx"),
                       "Other",
                       skip = 2) |> 
              mutate(across(
                contains("mm"),
                as.numeric
              ))) %>%
  clean_names()


spp_comp <- spp_comp_2021 |> 
  bind_rows(spp_comp_2022 |> 
              filter(!is.na(as.numeric(count)))) |> 
  select(all_of(intersect(names(spp_comp_2022), names(spp_comp_2021)))) |> 
  mutate(year = year(date)) |> 
  relocate(year, .before = 1) |> 
  mutate(fork_length_cm = fork_length_mm / 10) |> 
  relocate(fork_length_cm,
           .after = "fork_length_mm") |> 
  mutate(across(gear,
                ~ fct_relabel(.,
                              ~ if_else(str_detect(., "Hook"),
                                        "hook and line",
                                        .))),
         across(gear,
                ~ fct_relabel(.,
                              ~ str_to_lower(.))),
         across(species,
                ~ recode(.,
                         "RAINBOW" = "Resident rainbow",
                         "Bull Trout" = "Bull trout")))

spp_fl <- spp_comp |> 
  filter(rml < 12) |> 
  select(date,
         species,
         gear,
         fork_length_cm) |> 
  filter(!is.na(fork_length_cm)) |> 
  mutate(spp_fct = if_else(species == "Steelhead",
                           1, 0)) %>%
  mutate(across(c(species,
                  spp_fct),
                as_factor)) %>%
  mutate(jday = yday(date),
         fl_mean = mean(fork_length_cm),
         fl_sd = sd(fork_length_cm),
         fl_z = (fork_length_cm - fl_mean) / fl_sd)

```


```{r operational-time}
# generate percent of each time step sonar was operational
half_hr_op <- half_hr_periods %>%
  group_by(year, 
           date,
           time,
           hour,
           hr_fct) %>%
  summarize(across(date_time,
                   min),
            tot_pers = n(),
            op_pers = sum(operational),
            op_perc = op_pers / tot_pers,
            .groups = "drop")

hr_op <- half_hr_periods %>%
  group_by(year, 
           date,
           hour,
           hr_fct,) %>%
  summarize(across(date_time,
                   min),
            tot_pers = n(),
            op_pers = sum(operational),
            op_perc = op_pers / tot_pers,
            .groups = "drop")

hrs_op <- half_hr_periods %>%
  group_by(year, 
           date,
           hr_fct) %>%
  summarize(hour = hour[date_time == min(date_time)],
            across(date_time,
                   min),
            tot_pers = n(),
            op_pers = sum(operational),
            op_perc = op_pers / tot_pers,
            .groups = "drop") |> 
  select(any_of(names(half_hr_op)))

day_op <- half_hr_periods %>%
  group_by(year, 
           date) %>%
  summarize(hour = hour[date_time == min(date_time)],
            hr_fct = hr_fct[date_time == min(date_time)],
            across(date_time,
                   min),
            tot_pers = n(),
            op_pers = sum(operational),
            op_perc = op_pers / tot_pers,
            .groups = "drop") |> 
  select(any_of(names(half_hr_op)))

ops_df <- tibble(time_scale = as_factor(c('Hour',
                                          paste(24 / max(hrs_fct_grp), 'Hour Block'),
                                          'Day')),
                 ops = list(hr_op,
                            hrs_op,
                            day_op))

```



\newpage
# Introduction

In 2019 the Washington Department of Fish and Wildlife (WDFW) installed and operated a stationary multi-beam SONAR unit in the lower Dungeness River to enumerate and gather run-timing information on winter steelhead (*Onchorhynchus mykiss*). Steelhead spawning ground surveys in the Dungeness River basin are inherently challenging due to springtime snow melt and rain events which can lead to high, turbid water and dangerous survey conditions. In most years it is not possible to survey for steelhead through the entirety of the spawning season, and in some years poor survey conditions prevent an adequate number of surveys to estimate redd-based escapement. SONAR may provide an alternative method for steelhead enumeration and run timing in a dynamic, turbid snow-melt system like the Dungeness watershed.

Our goal here is to translate SONAR data from the Dungeness into estimates of steelhead escapement, by brood year. 

This involves several sub-tasks:

1. Exclude bull trout from images based on species composition data.
1. Expand 30 min observations into 60 min estimates. Most hours only the first 30 min of video was analyzed, but for a subset of hours the entire hour was analyzed. Develop a crosswalk between the first 30 min and the entire hour, and then predict the total counts from all the hours when only the first 30 min are available, with uncertainty from this crosswalk.
1. Account for outages. There are periods when the sonar unit was not functioning for a variety of reasons. Implement a method to interpolate across those periods of missing data.


# Methods

## SONAR operation
In 2019, the SONAR unit was deployed at approximately river mile (RM) 0.3, below the majority of steelhead spawning habitat (Figure \@ref(fig:site-map)). 

```{r site-map, fig.width = 5, fig.height = 5, fig.cap = "Location of the SONAR site (white X) in the lower Dungeness River in 2019."}
knitr::include_graphics(here("analysis/figures",
                             "sonar_site_map.png"))
```

The SONAR was mounted to a pole mount and attached to a reinforced ladder, secured to the river bottom by rebar (Figure \@ref(fig:sonar-pic)). The SONAR was placed along the hardened left bank, in a spot that was protected, but that retained adequate depth so that the SONAR unit and ladder did not need to be shifted laterally to accommodate changing water levels. The SONAR site ensonified an approximately 20 meter (m) wide run in the river that fish actively migrate past, reducing the possibility of milling or holding fish. This site was easily accessible from the field trailer site, which enabled the unit to be directly connected and powered by trailer power, and any adjustments to the SONAR settings to be accomplished in the dry, safe comfort of the trailer. 

A picket weir was constructed approximately 1 m above the SONAR unit from the bank to approximately 1 m past the SONAR to deflect debris and help direct migrating fish out in front of the unit. 

```{r sonar-pic, fig.cap = "ARIS 1800 SONAR unit deployment in the Dungeness River."}
knitr::include_graphics(here("analysis/figures",
                             "sonar_pic.jpg"))
```

We deployed the ARIS 1800 Explorer, manufactured by Sound Metrics, of Bellevue, Washington. The ARIS 1800 uses 96 beams to project an acoustic wedge that ensonifies the water column. The SONAR unit was adjusted to have a pitch of 3.5 degrees to -8 degrees to ensonify the entire water column and was checked daily and adjusted as necessary to maintain full ensonification of the channel. Imagery was continuously recorded 24 hours a day, and saved in 30-minute files, so that 48 individual files were recorded for each full day of operation.  

The SONAR was operated continuously from March 5, 2019 until October 10, 2019. This report focuses on the steelhead migration period between March 5 and June 24th, 2019. From March 5th to June 24th, there were 8 days with partial data recording gaps (7% of 112 days). Four of these gaps were 1 hour or less; the other 2 data gaps ranged from approximately 18 hours (March 9 and 10) to 20 hours (April 9 and 10, Figure 3a). 

## Data Processing

The first 30 minutes of each hour were processed and reviewed for fish migration. This subsampling scheme enabled the SONAR project team to keep up with data review throughout the season, and to complete a review of the entire steelhead migration period. Some number of days were fully reviewed (60 minutes of each hour) each year to compare fish migration with subsampled (30 minutes of each hour) data (Table \@ref(tab:full-hr-tab)). Each reviewed imagery file was processed using Sound Metric’s proprietary software ARISFish (v2.6.3). First, raw image files were background subtracted, which removed static objects from the image so that only objects in motion are shown. Then, an echogram was created, which transformed the image into a graph of distance (y-axis) and time (x-axis), so that objects in motion appeared as white “tracks.” The echogram enabled the data reviewer to quickly navigate to parts of the image file that contained objects that could be migrating fish. These tracks were then manually viewed alongside the raw image file to determine if the object was a fish to be further investigated. 

```{r full-hr-tab}
full_hrs |> 
  mutate(dh = date + hour) |> 
  group_by(year) |> 
  summarize(n_days = n_distinct(date),
            n_hours = n_distinct(dh),
            .groups = "drop") |> 
  clean_names("title") |> 
  kable(booktabs = T,
        caption = "Number of days and hours each year that had 60 minutes of sonar data reviewed.") |> 
  kable_styling()
```


Fish greater or equal to 45 centimeters (cm) were measured, marked, and counted using the ARISFish software. Forty-five cm was determined to be the minimum length of a potential steelhead, based on captures of steelhead during sampling in the Dungeness River 2014, 2015, and 2017 by the Jamestown S’Klallam Tribe (JSK) (unpublished data, C. Burns). Only fish that completely moved through the SONAR beams were counted; fish that nosed in and out or did not completely move from one side of the beams to the other were not counted. For each fish counted the following data were recorded:
* Date
* Hour of the 30-minute image file (e.g., 14:00, 14:30)
* Time 
* Frame
* Direction of travel (upstream or downstream)
* Range (distance from the SONAR)
* Length of the fish in cm
* Data reviewer confidence (1: extremely confident that the object counted is a fish ≥ 45 cm, 2: somewhat confident that the object is a fish ≥ 45 cm, 3: object of interest)

If no fish were observed in the 30-minute image file, a line of data with “NO FISH” was recorded to indicate that the file was reviewed for fish, but no fish ≥ 45 cm were present. Marked fish were automatically saved within the image file for later error checking; data were also recorded within an Excel spreadsheet for data summarization and analysis. 

## Species Composition

**Something about how the species composition data was gathered**

## Analysis


### Excluding Bull Trout

Bull trout are swimming past the sonar unit as well as steelhead, and we need to parse which fish identified by the sonar are steelhead, and exclude any bull trout. The largest bull trout sampled in any species composition data was 67 cm, so we are assuming any fish larger than 67 cm detected on the sonar is a steelhead. It then remains to filter the fish equal to or less than 67 cm long from the sonar data and determine which of those are steelhead, and which are bull trout. 

We only have species composition data for two years, 2021 and 2022. It was collected weekly, using tangle nets just upstream of the sonar location. For every fish caught, we know the date and fork length of that fish. Based on this data, we have also determined that the steelhead run on the Dungeness is over by June 1. Therefore, we have only made predictions for fish detected prior to June 1st. 

<!-- We have several options to model the probability of any particular fish, less than or equal to 67 cm, being a steelhead. we could model that probability as a factor of date (perhaps with a quadratic term to capture non-linearity), or as a factor of fork length, or both. If we use date, we can interpret the probability of being a steelhead as the proportion of all fish detected on that date that are steelhead. If we use fork length (or date and fork length), we can assign a probability to every fish detected by sonar, and assume that all fish with a probability greater than some threshold (probably 50%) are steelhead.  -->

<!-- Currently, we are only using fork length, because although the date of capture is probably available, it is not in the current data set. From the species composition netting, there are `r nrow(spp_fl)` fish caught with fork lengths. These can be seen in Figure \@ref(fig:fl-hist). Since we only care about differentiating steelhead, we grouped resident rainbows with bull trout, and then fit a binomial GLM with a logit link, using the fork length to predict the probability of a fish being a steelhead. We did not restrict the dataset to fish with fork lengths less than 67 cm, because larger fish have information about the shape of the logistic curve.  -->

<!-- After fitting this GLM, we predicted the probability of being a steelhead for all fish observed on the sonar that were smaller than or equal to 67 cm, based on their length. Any fish with a probability of 50% or greater we assigned to be a steelhead. We then applied the same model (Section \@ref(expanding-30-min-to-60-min)) to expand 30 minute counts for small fish to full hour counts. We added counts or estimates of large fish to small fish for each time period to estimate total net steelhead moving upstream for each time period. Estimates of large and small fish within the same time period were assumed to be independent when calculating the standard error. -->

We modeled the probability of a fish being a steelhead using fork length and the Juilan day of capture. From the species composition netting, there are `r nrow(spp_fl)` fish to use in this model. These can be seen in Figures \@ref(fig:fl-hist) and \@ref(fig:fl-date). Since we only care about differentiating steelhead, we grouped resident rainbow and cutthroat trout with bull trout, and then fit a binomial GAM with a logit link, using splines of fork length and Julian day to predict the probability of a fish being a steelhead. We did not restrict the dataset to fish with fork lengths less than 67 cm, because larger fish have information about the shape of the logistic curve. 

After fitting this GAM, we predicted the probability of being a steelhead for all fish observed on the sonar that were smaller than or equal to 67 cm, based on their length and Julian day of observation. Any fish with a probability of 50% or greater we assigned to be a steelhead. 
<!-- We then applied the same model (Section \@ref(expanding-30-min-to-60-min)) to expand 30 minute counts for small fish to full hour counts. We added counts or estimates of large fish to small fish for each time period to estimate total net steelhead moving upstream for each time period. Estimates of large and small fish within the same time period were assumed to be independent when calculating the standard error. -->

```{r fl-hist, fig.cap = "Histogram of forklengths, colored by species. Dashed lines are the overlap range between steelhead and other species."}
spp_fl %>%
  ggplot(aes(x = fork_length_cm,
             fill = species)) +
  geom_histogram(position = "dodge",
                 binwidth = 4) +
  geom_vline(xintercept = c(45, 67),
             linetype = 2) +
  scale_fill_brewer(palette = "Set1",
                    name = "Species") +
  labs(x = "Fork Length (cm)",
       y = "Count")
```

```{r fl-date, fig.cap = "Scatterplot of date of capture and forklength, colored by species."}
spp_fl %>%
  ggplot(aes(x = jday,
             y = fork_length_cm,
             color = species)) +
  geom_point() +
  scale_color_brewer(palette = "Set1",
                     name = "Species") +
  labs(x = "Julian Day",
       y = "Fork Length (cm)")
```


```{r fl-gam, eval = T}
fl_mod <- spp_fl %>%
  gam(spp_fct ~ s(fl_z, k = 5, m = 2, bs = "tp") + 
        s(jday, k = 5, m = 2, bs = "tp"),
      data = .,
      family = binomial)
# glm(spp_fct ~ fl_z + jday + I(jday^2),
#     data = .,
#     family = binomial)

# what is the fork length when 50% of being a steelhead?
p_pred = 0.5
pred_tab <- crossing(length = seq(35, 75, by = 1),
                     survey_date = seq(ymd(20210203),
                                       ymd(20210601),
                                       by = "1 days")) %>%
  mutate(fl_z = (length - unique(spp_fl$fl_mean)) / unique(spp_fl$fl_sd),
         jday = yday(survey_date)) %>%
  bind_cols(predict(fl_mod,
                    newdata = .,
                    type = "response",
                    se.fit = T) %>%
              as_tibble() %>%
              select(prob_sthd = fit,
                     prob_se = se.fit))

```


```{r fl-glm, eval = F}
fl_mod <- spp_fl %>%
  glm(spp_fct ~ fl_z,
      data = .,
      family = binomial)

# summary(fl_mod)
# # probability of being steelhead at average forklength (~ 55 cm)
# boot::inv.logit(coef(fl_mod)[1])
# # if fork length increases by 1 standard deviation (~ 13 cm), 
# # odds of being a steelhead increase by a factor of:
# exp(coef(fl_mod)[2])

# what is the fork length when 50% of being a steelhead?
p_pred = 0.5
cut_pt <- boot::logit(p_pred) %>%
  subtract(coef(fl_mod)[1]) %>%
  divide_by(coef(fl_mod)[2]) %>%
  multiply_by(unique(spp_fl$fl_sd)) %>%
  add(unique(spp_fl$fl_mean)) %>%
  as.numeric()
```

```{r pred-small-fish}
# extract all steelhead from sonar data: big fish and small ones that are predicted to be steelhead
sonar_pred_spp <- sonar_fish %>%
  filter(confidence == 1) |> 
  rename(fork_length_cm = length) %>%
  mutate(#fork_length_mm = fork_length_cm * 10,
         fl_z = (fork_length_cm - unique(spp_fl$fl_mean)) / unique(spp_fl$fl_sd)) %>%
  mutate(jday = yday(date_time)) %>%
  bind_cols(predict(fl_mod,
                    newdata = .,
                    type = "response",
                    se.fit = T) %>%
              as_tibble() %>%
              select(prob_sthd = fit,
                     prob_se = se.fit)) %>%
  mutate(p_alpha = prob_sthd^2 * ((1 - prob_sthd) / prob_se^2 - prob_sthd^-1),
         p_beta = p_alpha * (prob_sthd^-1 - 1))

sonar_sthd <- sonar_pred_spp |> 
  select(-c(p_alpha, p_beta)) |> 
  filter(sthd_length | prob_sthd > 0.5)
```

```{r, create-time-series}
# create complete time-series by adding counts of upstream, downstream and net steelhead to hr_periods
ts_long <- hr_periods |> 
  left_join(ops_df |>
              filter(time_scale == "Hour") |>
              pull(ops) |>
              extract2(1) |>
              select(date_time, op_perc)) |>
  mutate(across(op_perc,
                ~ replace_na(., 0))) |>
  crossing(direction = c("up", "down")) |>
  left_join(sonar_sthd %>%
              group_by(year,
                       date,
                       time = hour) %>%
              count(direction,
                    name = "n_fish") %>%
              ungroup() %>%
              filter(direction %in% c("upstream",
                                      "downstream")) %>%
              mutate(across(direction,
                            ~ recode(.,
                                     "upstream" = "up",
                                     "downstream" = "down"))) |> 
              mutate(half_hr_period = if_else(str_detect(time, "30M"),
                                              "second",
                                              "first")) |> 
              mutate(hour = if_else(str_detect(time, "30M"),
                                    time - minutes(30),
                                    time)) |> 
              select(-time) |> 
              pivot_wider(names_from = half_hr_period,
                          values_from = n_fish)) |> 
  mutate(
    across(first,
           ~ if_else(is.na(.) & data_reviewed %in% c("Full Hour", "First 30 Only"),
                     0, .)),
    across(second,
           ~ if_else(is.na(.) & data_reviewed %in% c("Full Hour", "Second 30 Only"),
                     0, .)),
  )

# add net upstream movement
ts_long <- ts_long |> 
  bind_rows(ts_long |> 
              pivot_longer(cols = c(first, 
                                    second),
                           names_to = "period",
                           values_to = "n_fish") |> 
              pivot_wider(names_from = direction,
                          values_from = n_fish) |> 
              mutate(net = up - down) |> 
              select(-up, - down) |> 
              mutate(direction = "net") |> 
              pivot_wider(names_from = period,
                          values_from = net)) |> 
  mutate(across(direction,
                ~ factor(.,
                         levels = c("down",
                                    "up",
                                    "net")))) |> 
  arrange(date_time,
          direction)



# some hours had only the 2nd half hour reviewed. Switch that to pretend it's the first half hour
ts_long <- ts_long |> 
  filter(data_reviewed != "Second 30 Only") |> 
  bind_rows(ts_long |> 
              filter(data_reviewed == "Second 30 Only") |> 
              mutate(first = second,
                     second = NA_real_,
                     data_reviewed = "First 30 Only")) |> 
  arrange(date_time,
          direction)

analysis_grps <-
  tibble(time_scale = as_factor(c('Hour',
                                  paste(24 / max(hrs_fct_grp), 'Hour Block'),
                                  'Day')),
         ts_df = list(ts_long |> 
                      mutate(fct_group = date_time,
                               across(fct_group,
                                      ~ factor(as.character(.),
                                               labels = 1:n_distinct(.)))) |> 
                        select(fct_group,
                               everything()),
                      
                      ts_long |> 
                        unite(fct_group, date, hr_fct, remove = F) |> 
                        mutate(across(fct_group,
                                      ~ factor(as.character(.),
                                               labels = 1:n_distinct(.)))) |> 
                        group_by(year, 
                                 date, 
                                 direction,
                                 hr_fct,
                                 fct_group) %>%
                        summarize(across(date_time,
                                         min),
                                  n_pers = n(),
                                  n_reviewed = sum(reviewed),
                                  n_full_hrs = sum(full_hr),
                                  across(c(data_recorded,
                                           data_reviewed),
                                         ~ paste(sort(unique(.)), collapse = "_")),
                                  across(c(first, 
                                           second),
                                         ~ sum(., na.rm = T)),
                                  .groups = "drop") |>
                        mutate(full_hr = if_else(n_full_hrs > 0,
                                                 T, F),
                               reviewed = if_else(n_reviewed > 0,
                                                  T, F)) |> 
                        mutate(hour = hour(date_time),
                               across(hour,
                                      ~ as.period(.,
                                                  unit = "hour"))) |> 
                        select(fct_group,
                               any_of(names(ts_long))),
                      
                      ts_long |> 
                        mutate(fct_group = date,
                               across(fct_group,
                                      ~ factor(as.character(.),
                                               labels = 1:n_distinct(.)))) |> 
                        group_by(year,
                                 date, 
                                 direction, 
                                 fct_group) %>%
                        summarize(across(date_time,
                                         min),
                                  n_pers = n(),
                                  n_reviewed = sum(reviewed),
                                  n_full_hrs = sum(full_hr),
                                  across(c(data_recorded,
                                           data_reviewed),
                                         ~ paste(sort(unique(.)), collapse = "_")),
                                  across(c(first, 
                                           second),
                                         ~ sum(., na.rm = T)),
                                  .groups = "drop") |> 
                        mutate(full_hr = if_else(n_full_hrs > 0,
                                                 T, F),
                               reviewed = if_else(n_reviewed > 0,
                                                  T, F)) |> 
                        mutate(hour = hour(date_time),
                               across(hour,
                                      ~ as.period(.,
                                                  unit = "hour")),
                               hr_fct = 1) |> 
                        select(fct_group,
                               any_of(names(ts_long)))
                      )) |> 
  unnest(ts_df) |> 
  mutate(across(second,
                ~ if_else(!full_hr,
                          NA_real_,
                          .)),
         across(first,
                ~ if_else(!reviewed,
                          NA_real_,
                          .))) |> 
  select(-operational,
         -op_perc) |> 
  left_join(ops_df |> 
              unnest(ops) |> 
              select(-ends_with("pers"))) |> 
  nest(data = -c(time_scale,
                 direction,
                 reviewed,
                 full_hr))
           
```



### Expanding 30 min to 60 min

```{r mod-data}
# period comparison for all hours with first and second half hours fully recorded
comp_30_df <- analysis_grps %>%
  filter(full_hr,
         reviewed) %>%
  unnest(data) %>%
  mutate(total = first + second) |> 
  arrange(time_scale,
          date_time,
          direction) |> 
  add_column(est_type = "Full Hour Census",
             .before = "first")

# group data by different time-scales and directions
# filter out hours with no fish at all
per_fit_df <- comp_30_df |> 
  filter(total > 0) |> 
  nest(model_df = -c(time_scale,
                     direction)) |> 
  arrange(time_scale,
          direction)

```


We started by examining the counts during the first 30 minutes and the entire hour. First, we filtered for records with a confidence level of 1 (extremely confident) and fish we predicted to be steelhead based on length and Julian date. For each half hour reviewed, we summed the fish determined to be moving upstream, and those moving downstream. For hours when a full 60 minutes were reviewed, we added the first and second half hours together, calculating a total of upstream- and downstream-moving fish for that hour. We then extracted only those hours with 60 min reviewed for further analysis. 

We compared the first half hour with the entire hour at several temporal scales. We started with a single hour, then also summed net upstream fish in `r 24 / max(hrs_fct_grp)` hour blocks, and finally summed the net upstream fish by date. The data was structured such that hours where both half hours were examined were usually consecutive at least up to the day scale, meaning each `r 24 / max(hrs_fct_grp)` hour block and each day had nearly identical amounts of time with two half hours to other periods at the same temporal scale.

For each temporal scale grouping, we fit a linear model with the counts of net upstream fish in the first 30 minutes as the independent variable and the total net upstream fish for the hour as the dependent variable. In each model, we fixed the intercept at 0, to ensure that if no fish were counted in the first half hour, we would expand that to zero fish for the entire hour. We focused on the estimated slope, hypothesizing that it should be 2. 

```{r fit-models}
per_fit_df %<>%
  mutate(mod = map(model_df,
                   .f = function(x) {
                     lm(total ~ first - 1,
                        data = x)
                     # lm(log(total) ~ log(first) - 1,
                     #    data = x |> 
                     #      filter(first > 0))
                     glm(total ~ first,
                         data = x,
                         family = "poisson")
                   }),
         coefs = map(mod,
                     .f = broom::tidy),
         ci = map(mod,
                  .f = function(x) {
                    ci = confint(x)
                    if(class(ci)[1] == "matrix") {
                      ci %<>%
                        as_tibble()
                    } else {
                      ci %<>%
                        enframe() %>%
                        pivot_wider()
                    }
                    return(ci)
                  })) %>%
  mutate(slope = map_dbl(coefs,
                         "estimate"),
         se = map_dbl(coefs,
                      "std.error"),
         sigma = map_dbl(mod,
                         .f = function(x) {
                           summary(x)$sigma
                         }),
         R2 = map_dbl(mod,
                      .f = function(x) {
                        summary(x)$r.squared
                      }),
         adj_R2 = map_dbl(mod,
                          .f = function(x) {
                            summary(x)$adj.r.squared
                          })) %>%
  unnest(ci) %>%
  relocate(ends_with("%"),
           .after = "se")

```

```{r}
# per_fit_final <- per_fit_df

#-----------------------------------
# settled on modeling up and down separately, on daily scale
per_fit_final <- per_fit_df |>
  filter(time_scale == "Day",
         direction %in% c("up",
                          "down"))
```

```{r make-predictions-miss-half-hours}
# predict number of steelhead-sized fish going by during only half hour review periods
half_hr_pred <- analysis_grps %>%
  filter(!full_hr,
         reviewed) %>%
  inner_join(per_fit_final %>%
               select(time_scale,
                      direction,
                      mod),
             by = c("time_scale",
                    "direction")) %>%
  mutate(preds = map2(mod,
                      data,
                      .f = function(x, y) {
                        predict(x,
                                newdata = y,
                                se.fit = T)
                      }),
         total = map(preds,
                     "fit"),
         se = map(preds,
                  "se.fit"),
         resid_scale = map(preds,
                           "residual.scale")) %>%
  mutate(pred_ci = map2(mod,
                        data,
                        .f = function(x, y) {
                          predict(x,
                                  newdata = y,
                                  interval = "prediction") %>%
                            as_tibble() %>%
                            select(lci = lwr,
                                   uci = upr)
                        })) %>%
  select(-mod, -preds) %>%
  unnest(cols = c(data, total, 
                  se, resid_scale, 
                  pred_ci)) %>%
  # assume first 30 min is exactly 1/2 of full hour
  mutate(total = 2 * first,
         # for prediction intervals (instead of confidence, adjust the standard error)
         # se = sqrt(se^2 + resid_scale^2),
         lci = qnorm(0.025, total, se),
         uci = qnorm(0.975, total, se)) |> 
  select(-resid_scale) |> 
  select(-fct_group) %>%
  add_column(est_type = "Half Hour Exp.",
             .before = "first")

```

```{r}
# put all steelhead-sized fish together (reviewed and predicted)
all_sthd <- comp_30_df |>
  inner_join(half_hr_pred |> 
              select(time_scale,
                     direction) |> 
              distinct()) |> 
  bind_rows(half_hr_pred) |> 
  arrange(time_scale,
          date_time,
          direction) |> 
  select(-fct_group) |>
  mutate(across(se,
                ~ if_else(full_hr,
                          0,
                          .)),
         across(c(lci,
                  uci),
                ~ if_else(full_hr,
                          total,
                          .))) |> 
  nest(sthd_est = -c(time_scale,
                     direction,
                     reviewed,
                     full_hr)) |>
  mutate(n_est = map_dbl(sthd_est, nrow))

# add the missing data
all_sthd <- all_sthd |> 
  bind_rows(analysis_grps |>
              filter(time_scale %in% unique(all_sthd$time_scale),
                     direction %in% unique(all_sthd$direction)) |> 
              anti_join(all_sthd) |> 
              mutate(sthd_est = map(data,
                                    .f = function(x) {
                                      select(x,
                                             -fct_group)
                                    })) |> 
              select(-data)) |> 
  arrange(time_scale,
          reviewed,
          full_hr,
          direction)

# analysis_grps |>
#   mutate(n_data = map_dbl(data,
#                           nrow)) |>
#   full_join(all_sthd |>
#               nest(sthd_est = -c(time_scale,
#                                  direction,
#                                  reviewed,
#                                  full_hr)) |>
#               mutate(n_est = map_dbl(sthd_est, nrow)))

```

### Missing Data

There are periods when the sonar was not functioning, for a variety of reasons. Rather than ignore those time periods, and assume that no steelhead were passing then, we would prefer to impute net upstream fish for those missing values.

The first step is to expand the estimates of net upstream fish for periods when the sonar only partially operated (e.g. 14 hours out of a 24 hour day). We did this by dividing the estimate for that period by the percent of time the sonar was operational in that period. This assumes that fish are behaving similarly for that entire period. 

The next step is to deal with those periods when the sonar was not operating at all, where we have truly missing data. Table \@ref(tab:miss-data) shows how much data was missing for each year, depending on how the periods were constructed (e.g. hourly, hourly blocks, daily).


```{r, eval = T}
# set a threshold below which we won't expand by the operating percent
op_thres <- 0.2

# expand estimates by percent sonar was operational in that period
fish_cnts <- all_sthd |> 
  # filter(!is.na(n_est)) |>
  select(-n_est) |> 
  unnest(sthd_est) |>
  mutate(across(reviewed,
                ~ if_else(op_perc < op_thres, F, .)),
         across(total,
                ~ if_else(op_perc >= op_thres,
                          . / op_perc,
                          NA_real_)),
         across(est_type,
                ~ if_else(reviewed & op_perc >= op_thres & op_perc < 1,
                          "Missing Time Exp.",
                          if_else(op_perc < op_thres | !reviewed,
                                  "Missing Data",
                                  .))),
         across(c(se, lci, uci),
                ~ if_else(est_type == 'Missing Data',
                          NA_real_,
                          .))) |> 
  arrange(time_scale,
          date_time,
          direction)

# fish_cnts |> 
#   nest(sthd_est = -c(time_scale,
#                      direction,
#                      reviewed,
#                      full_hr)) |>
#   mutate(n_est = map_dbl(sthd_est, nrow))

```


```{r create-time-series}
library(zoo)
library(forecast)
library(imputeTS)

ts_est <- fish_cnts %>%
  select(time_scale,
         direction,
         year,
         date_time,
         est_type,
         total, se) %>%
  nest(data = -c(time_scale,
                 direction,
                 year)) %>%
  mutate(n_periods = map_dbl(data,
                             .f = function(x) {
                               nrow(x)
                             }),
         n_NA = map_dbl(data,
                        .f = function(x) {
                          sum(is.na(x$total))
                        }),
         perc_NA = n_NA / n_periods,
         ts_zoo = map(data,
                      .f = function(x) {
                        zoo(x$total,
                            x$date_time)
                      }),
         ts = map(data,
                  .f = function(x) {
                    ts(x$total)
                  })) %>%
         # ts = map(ts_zoo,
         #          as.ts)) %>%
  # fit some ARIMA models
  mutate(auto_arima = map(ts,
                          .f = auto.arima,
                          seasonal = F,
                          allowdrift = F,
                          stepwise = F,
                          ic = "aicc"),
         order = map_chr(auto_arima,
                         .f = function(x) {
                           arimaorder(x) %>%
                             as.vector() %>%
                             paste(collapse = " ")
                         }),
         sigma2 = map_dbl(auto_arima,
                          "sigma2"),
         se = sqrt(sigma2))

```

```{r impute-missing}
ts_est %<>%
  # make predictions based on best ARIMA model
  mutate(kalman_preds = map(ts,
                            .f = function(x) {
                              na_kalman(x,
                                        model = "auto.arima",
                                        smooth = T) %>%
                                as_tibble() %>%
                                rename(kalman_pred = x)
                            }),
         # predict based on linear interpolation
         lin_preds = map(ts,
                         .f = function(x) {
                           na_interpolation(x,
                                            option = "linear") %>%
                             as_tibble() %>%
                             rename(lin_pred = x)
                         }),
         # predict based on moving average
         ma_preds = map(ts,
                        .f = function(x) {
                          na_ma(x,
                                k = 4,
                          ) %>%
                            as_tibble() %>%
                            rename(ma_pred = x)
                        }))

# combine all predictions back with existing counts
all_preds <- fish_cnts %>%
  full_join(ts_est %>%
              select(time_scale,
                     direction,
                     year,
                     data,
                     pred_se = se,
                     ends_with("preds")) %>%
                     # kalman_preds) |>
              unnest(cols = c(data, ends_with("preds"))) %>%
              # mutate(across(contains("pred"),
              #               ~ if_else(est_type != "Missing Data",
              #                         NA_real_,
              #                         .))) %>%
              filter(est_type == "Missing Data") %>%
              select(-total,
                     -se) %>%
              pivot_longer(ends_with("pred"),
                           names_to = "model",
                           values_to = "est") %>%
              mutate(across(model,
                            str_remove,
                            "_pred$")) %>%
              mutate(lci_ts = qnorm(0.025, est, pred_se),
                     uci_ts = qnorm(0.975, est, pred_se)) |> 
              mutate(across(est,
                            ~ if_else(. < 0, 0, .))),
            multiple = "all") %>%
  # mutate(model = if_else(is.na(model),
  #                        if_else(est_type == "Half Hour Exp.",
  #                                "expansion",
  #                                "none"),
  #                        model)) %>%
  rowwise() |> 
  mutate(total = if_else(est_type == "Missing Data",
                         max(c(first, est), na.rm = T),
                         total),
         lci = if_else(est_type == "Missing Data",
                       lci_ts,
                       lci),
         uci = if_else(est_type == "Missing Data",
                       uci_ts,
                       uci),
         se = if_else(est_type == "Missing Data",
                      pred_se,
                      se)) |> 
  ungroup() |> 
  select(any_of(names(fish_cnts)),
         model) |> 
  arrange(time_scale,
          date_time,
          direction)

# all_preds %>%
#   # filter(!model %in% c("lin",
#   #                      "ma")) %>%
#   group_by(model,
#            time_scale,
#            year) %>%
#   summarize(across(c(total,
#                      lci,
#                      uci),
#                    sum),
#             across(se,
#                    ~ sqrt(sum(.^2)))) %>%
#   mutate(lci_v2 = qnorm(0.025, total, se),
#          uci_v2 = qnorm(0.975, total, se))


# choose Kalman filter method to fill in missing data
full_est_ts <- all_preds |> 
  filter(is.na(model) |
           model == "kalman") |>
  select(-model)

# add total upstream estimates (net upstream)
full_est_ts <- full_est_ts |> 
  bind_rows(full_est_ts |> 
              select(-lci,
                     -uci) |> 
              pivot_longer(cols = c(first, 
                                    second,
                                    total,
                                    se)) |>
              pivot_wider(names_from = direction,
                          values_from = value) |> 
              rowwise() |> 
              mutate(net = if_else(name != "se",
                                   up - down,
                                   sqrt(sum(c(up, down)^2)))) |> 
              mutate(direction = "net") |> 
              select(-c(down, up)) |> 
              pivot_wider(names_from = name,
                          values_from = net) |> 
              rowwise() |>
              mutate(lci = qnorm(0.025, total, se),
                     uci = qnorm(0.975, total, se)) |> 
              ungroup()) |> 
  mutate(across(direction,
                ~ factor(.,
                         levels = c("down",
                                    "up",
                                    "net")))) |> 
  arrange(date_time,
          direction)
```

```{r}
# save for other analyses
save(sonar_raw,
     half_hr_periods,
     sonar_sthd,
     ts_long,
     # analysis_grps,
     # all_sthd,
     op_thres,
     fish_cnts,
     # all_preds,
     full_est_ts,
     hrs_fct_grp,
     ops_df,
     file = here("analysis/data/derived_data",
                 "est_fish_cnts.rda"))
```


```{r}
full_est_ts |>
  filter(direction != "net") |> 
  mutate(date_noyr = as.Date(paste(month(date), mday(date)), format = "%m %d"),
         across(direction,
                str_to_title)) %>%
  ggplot(aes(x = date_noyr,
             y = total,
             color = direction,
             fill = direction)) +
  geom_ribbon(aes(ymin = lci,
                  ymax = uci),
              color = NA,
              alpha = 0.2) +
  geom_hline(yintercept = 0,
             linetype = 3) +
  geom_line() +
  # geom_point() +
  facet_wrap(~ year) +
  coord_cartesian(ylim = c(-8, NA)) +
  labs(x = "Date",
       y = "Total Steelhead",
       color = "Direction",
       fill = "Direction")


full_est_ts |> 
  group_by(time_scale,
           direction,
           year) |> 
  summarize(across(total,
                   sum),
            across(se,
                   ~ sqrt(sum(.^2))),
            .groups = "drop") |> 
  pivot_wider(names_from = direction,
              values_from = c(total,
                              se)) |> 
  mutate(total_subt = total_up - total_down,
         se_subt = msm::deltamethod(~ x1 - x2,
                                    mean = c(total_up,
                                             total_down),
                                    cov = diag(c(se_up,
                                                 se_down)^2))) |> 
  select(-ends_with("up"),
         -ends_with("down")) |> 
  pivot_longer(c(starts_with("total"),
                 starts_with("se"))) |> 
  mutate(type = str_split(name, "_", simplify = T)[,1],
         method = str_split(name, "_", simplify = T)[,2]) |> 
  select(-name) |> 
  pivot_wider(names_from = type,
              values_from = value)

```


```{r miss-data}
ts_est %>%
  select(time_scale, year,
         n_periods:perc_NA) %>%
  distinct() %>%
  mutate(across(perc_NA,
                ~ . * 100)) %>%
  arrange(year,
          time_scale) %>%
  kable(booktabs = T,
        linesep = "",
        col.names = c("Time Scale",
                      "Year",
                      "n Periods",
                      "n NAs",
                      "% NA"),
        digits = c(rep(0, 4), 1),
        caption = "Table showing how many periods are in each group of data, and how many of those periods are NAs (missing values).") %>%
  kable_styling() #%>%
  # row_spec(row = c(3, 6),
  #          hline_after = T)
```

To interpolate across those periods of missing data, we employed time-series models. Using the `forecast` package in R, we fit an ARIMA (auto-regressive integrated moving average) model, and let the `auto.arima` function determine the model with the best order (number of auto-regressive, moving average and difference steps) for each year and time-scale combination. We used the uncertainty from this model ($\sigma^2$) for all predictions. 

We examined several forms of interpolation across the missing data, including a Kalman filter, linear regression and moving average. The Kalman filter uses the ARIMA structure to estimate the missing data. A linear regression essentially draws a straight line from the data point prior to the first missing data and the data point after the last missing data point for each gap in the time series. A moving average approach uses two non-missing values prior to the missing data point, and two non-missing values after, weights them exponentially by their distance from the missing data point, and calculates the weighted mean. 

\newpage
# Results

## Expanding 30 min to 60 min

The expansion factor (i.e. slope) changes depending on the temporal scale that data is summarized on. Figure \@ref(fig:period-comp-fig) shows the various regressions, comparing them with the 1-1 line and the expected slope of two. None of the temporal scales produced a slope of two, but the longer the temporal scale the closer it got to that expected value. 

```{r period-comp-fig, fig.cap = "Scatter plots showing the counts of fish moving upstream and downstream, using hours with both the first 30 minutes and second 30 minutes. The counts are summarized by hour, six hour blocks and entire day (24 hours) in the different columns The dashed red line is has a slope of 2 (expected value), the dotted grey line has a slope of 1, and the blue line is the linear regression fit to that data, with 95% confidence intervals."}
per_fit_df %>%
  select(time_scale,
         direction,
         model_df) %>%
  mutate(across(direction,
                str_to_title)) |> 
  unnest(model_df) %>%
  ggplot(aes(x = first,
             y = total)) +
  geom_abline(slope = 2,
              linetype = 2,
              color = "red") +
  geom_abline(slope = 1,
              linetype = 3,
              color = "gray30") +
  geom_smooth(method = "lm",
              formula = y ~ x - 1) +
  # geom_point() +
  geom_point(position = position_jitter(0.2, 0.2,
                                        seed = 4)) +
  facet_wrap(~ direction + time_scale,
             nrow = 3,
             scales = "free") +
  labs(x = "Counts in the first 30 minutes",
       y = "Counts for the entire hour")
```


Table \@ref(tab:lin-coef-tab) shows the summary of linear models fit to data summarized at various time scales. We summarized the estimated number of steelhead larger than 67 cm at the day scale (summing estimates at smaller temporal scales) and plotted the time-series in Figure \@ref(fig:ts-est) to show the differences caused by summarizing data at different time scales. 

```{r lin-coef-tab}
per_fit_df %>%
  mutate(across(ends_with("%"),
                round,
                2)) %>%
  mutate(CI = paste(`2.5 %`, `97.5 %`, sep = "-")) %>%
  select(time_scale,
         direction,
         slope,
         se,
         CI,
         adj_R2) %>%
  kable(col.names = c("Time Scale",
                      "Direction",
                      "Slope",
                      "SE",
                      "95% CI",
                      "R2"),
        digits = 2,
        booktabs = T,
        linesep = "",
        caption = "Results of fitting linear models with total counts of fish for the whole hour as the response and the counts of fish in the first 30 minutes as the covariate with no intercept.") %>%
  kable_styling()

```

```{r big-est, eval = F}
big_sthd %>%
  group_by(time_scale,
           year) %>%
  summarize(total = sum(total, na.rm = T),
            se = sqrt(sum(se^2, na.rm = T)),
            .groups = "drop") %>%
  arrange(year, time_scale) %>%
  kable(booktabs = T,
        linesep = "",
        col.names = c("Time Scale",
                      "Year",
                      "Estimate",
                      "SE"),
        digits = c(0, 0, 0, 2),
        caption = "Estimates of total net upstream fish larger than 67 cm, using only extremely confident observations. There are three estimates per year, corresponding to the three different regression models for expanding 30 minute observations.") %>%
  kable_styling() %>%
  row_spec(row = c(3, 6),
           hline_after = T)
```

```{r ts-est, eval = F, fig.height = 7, fig.cap = "Time-series of estimates based on available data, using only extremely confident observations of fish greater than 67 cm, faceted by year. Colors correspond to which regression model was used to expand the 30 minutes observations. Any uncertainty shown is derived from the linear regression model."}
big_sthd %>%
  full_join(ops_df %>%
              unnest(ops)) %>%
  group_by(time_scale,
           year,
           date) %>%
  summarize(avg_op = mean(op_perc),
            n_full_hr = sum(total > 0 & se == 0, na.rm = T),
            n_est = n(),
            n_nas = sum(is.na(total)),
            total = sum(total, na.rm = T),
            se = sqrt(sum(se^2, na.rm = T)),
            .groups = "drop") %>%
  mutate(across(c(total, se),
                ~ if_else(avg_op == 0,
                          NA_real_,
                          .))) %>%
  ggplot(aes(x = date,
             y = total,
             color = time_scale,
             fill = time_scale)) +
  geom_hline(yintercept = 0,
             linetype = 2,
             color = "gray40") +
  geom_ribbon(aes(ymin = qnorm(0.025, total, se),
                  ymax = qnorm(0.975, total, se)),
              alpha = 0.2,
              color = NA) +
  geom_line() +
  # scale_color_brewer(palette = "Set1",
  #                    name = "Model") +
  # scale_fill_brewer(palette = "Set1",
  #                    name = "Model") +
  scale_color_viridis_d(name = "Model",
                        end = 0.8) +
  scale_fill_viridis_d(name = "Model",
                       end = 0.8) +
  facet_wrap(~ year,
             ncol = 1,
             scales = "free") +
  labs(x = "Date",
       y = "Net Upstream Fish")

```

```{r est-corr, eval = F}
cor_tab <- fish_cnts %>%
  group_by(time_scale,
           direction,
           year,
           date) %>%
  summarize(n_full_hr = sum(is.na(se)),
            total = sum(total, na.rm = T),
            se = sqrt(sum(se^2, na.rm = T)),
            .groups = "drop") %>%
  select(-n_full_hr,
         -se) %>%
  pivot_wider(names_from = time_scale,
              values_from = total) %>%
  select(-year,
         -date) %>%
  corrr::correlate(use = "pairwise.complete.obs",
                   method = "pearson",
                   quiet = T)

```


## Excluding Bull Trout

<!-- Figure \@ref(fig:fig-glm) shows the fitted GLM that predicts the probability of being a steelhead based on a fish's length. Note that a 67 cm long fish would have a  round(predict(fl_mod, newdata = tibble(fl_z = (67 - unique(spp_fl$fl_mean)) / unique(spp_fl$fl_sd)), type = "response"), 3) * 100% of being a steelhead with this model. -->

```{r fig-glm, eval = F, fig.cap = "Points show the fork length of steelhead (along the top) and non-steelhead (along the bottom), with the fitted binomial GLM in red. The dashed line shows where fish greater than that would have a greater than 50% probability of being a steelhead. The dotted line shows the 67 cm threshold for which fish we will be applying this model to."}
spp_fl %>%
  ggplot(aes(fork_length_mm,
             spp_fct)) +
  geom_point() +
  geom_vline(xintercept = cut_pt,
             linetype = 2) +
  geom_vline(xintercept = 67,
             linetype = 3) +
  # geom_smooth(method = glm,
  #             formula = y ~ x,
  #             method.args = list(family = binomial(link = "cauchit")),
  #             aes(color = "cauchit",
  #                 fill = "cauchit"),
  #             alpha = 0.2) +
  # geom_smooth(method = glm,
  #             formula = y ~ x,
  #             method.args = list(family = binomial(link = "probit")),
  #             aes(color = "probit",
  #                 fill = "probit"),
#             alpha = 0.2) +
# geom_smooth(method = glm,
#             formula = y ~ x,
#             method.args = list(family = binomial(link = "cloglog")),
#             aes(color = "cloglog",
#                 fill = "cloglog"),
#             alpha = 0.2) +
geom_smooth(method = glm,
            formula = y ~ x,
            method.args = list(family = binomial),
            aes(color = "logit",
                fill = "logit"),
            alpha = 0.2) +
  scale_color_brewer(palette = "Set1",
                     name = "Link Fnc.") +
  scale_fill_brewer(palette = "Set1",
                    name = "Link Fnc.") +
  theme(legend.position = "none") +
  labs(y = "Probability of Being a Steelhead",
       x = "Fork Length (cm)")

```

Figure \@ref(fig:fig-gam) shows the fitted GAM that predicts the probability of being a steelhead based on a fish's length and date of capture. Note that the mean probability of being a steelhead for a 67 cm long fish, averaged across the entire season, would be `r round(mean(pred_tab$prob_sthd[pred_tab$length == 67]), 3) * 100`% of being a steelhead with this model. Also note that a fish 60 cm long would not be considered a steelhead if observed at the very beginning of the season or after the beginning of May, but would if observed in late March or April. 

```{r fig-gam, fig.cap = "The color depicts the probability of fish being a steelhead given the date of capture and fork length. Fish above the black line would have a greater than 50% probability of being a steelhead. The dotted line shows the 67 cm threshold for which fish we will be applying this model to."}
pred_tab %>%
  ggplot(aes(x = survey_date,
             y = length,
             fill = prob_sthd)) +
  geom_tile() +
  theme(panel.border = element_blank(),
        panel.grid = element_blank(),
        legend.position = "bottom") +
  # scale_fill_viridis_c(name = "Probability of\nBeing a Steelhead") +
  scale_fill_continuous_diverging(name = "Probability of\nBeing a Steelhead",
                                  # palette = "Purple-Green",
                                  palette = "Cork",
                                  # palette = "Blue-Red 3",
                                  # rev = T,
                                  mid = 0.5) +
  geom_line(data = pred_tab %>%
              filter(prob_sthd >= p_pred) %>%
              group_by(survey_date) %>%
              filter(length == min(length)) %>%
              arrange(survey_date, length),
            color = "black") +
  geom_hline(yintercept = c(45, 67),
             linetype = 2,
             color = 'darkgray') +
  labs(x = "Date",
       y = "Fork Length (cm)")

```

```{r fig-pred-spp, fig.cap = "Plot shows Julian day and length of all species recorded on sonar with confidence of 1, colored by the probability of being a steelhead."}
sonar_pred_spp |>
  mutate(plot_date = ymd(20211231) + days(jday)) |> 
  ggplot(aes(x = plot_date,
             y = fork_length_cm,
             color = prob_sthd)) +
  geom_point() +
  scale_color_continuous_diverging(name = "Probability of\nBeing a Steelhead",
                                   # palette = "Purple-Green",
                                   palette = "Cork",
                                   # palette = "Blue-Red 3",
                                   # palette = "Berlin",
                                   # rev = T,
                                   mid = 0.5) +
  geom_hline(yintercept = c(45, 67),
             linetype = 2,
             color = 'darkgray') +
  theme(legend.position = "bottom") +
  labs(x = "Date",
       y = "Fork Length (cm)")
```

Applying this model and rule-set to all the observed fish smaller than or equal to 67 cm, including the predictive model to expand 30 minute counts to full hour counts, a number of additional steelhead are added to our estimate each year (Table \@ref(tab:sm-est)). The total estimates (including all fish larger than 67 cm, as well as fish less than or equal to 67 cm that are predicted to be steelhead) are shown in Table \@ref(tab:tot-est). 

```{r sm-est}
small_fish %>%
  group_by(time_scale, 
           year) %>%
  summarize(total = sum(total),
            se = sqrt(sum(se^2, na.rm = T)),
            .groups = "drop") %>%
  mutate(prnt_val = paste0(round(total), " (",
                           round(se, 1),
                           ")")) %>%
  select(-total, -se) %>%
  pivot_wider(names_from = year,
              values_from = prnt_val) %>%
  rename(`Time Scale` = time_scale) %>%
  kable(booktabs = T,
        linesep = "",
        digits = c(0, 0, 0, 2),
        caption = "Estimates (SE) of total net upstream steelhead smaller than 67 cm, using only extremely confident observations. There are three estimates per year, corresponding to the three different regression models for expanding 30 minute observations.") %>%
  kable_styling()

```

```{r tot-est}
fish_cnts %>%
  group_by(time_scale, 
           direction,
           year) %>%
  summarize(total = sum(total, na.rm = T),
            se = sqrt(sum(se^2, na.rm = T)),
            .groups = "drop") %>%
  pivot_wider(names_from = direction,
              values_from = c(total, se)) |> 
  mutate(total = total_up - total_down,
         se = msm::deltamethod(~ x1 - x2,
                               mean = c(total_up,
                                        total_down),
                               cov = diag(c(se_up,
                                            se_down)^2))) |> 
  select(-ends_with("down"),
         -ends_with("up")) |> 
  mutate(prnt_val = paste0(round(total), " (",
                           round(se, 1),
                           ")")) %>%
  select(-total, -se) %>%
  pivot_wider(names_from = year,
              values_from = prnt_val) %>%
  rename(`Time Scale` = time_scale) %>%
  kable(booktabs = T,
        linesep = "",
        digits = c(0, 0, 0, 2),
        caption = "Estimates (SE) of total net upstream steelhead, using only extremely confident observations. There are three estimates per year, corresponding to the three different regression models for expanding 30 minute observations.") %>%
  kable_styling()

```


## Missing Data

Figure \@ref(fig:oper-fig) shows the periods when the sonar array was not operating, and Figure \@ref(fig:miss-ts) shows how that impacts the time-series of fish counts. Note the large period in 2020 when the sonar was shut down due to COVID-19.

As the temporal scale on which counts are aggregated increases, the amount of missing data decreases. For example, if three hours are missing within a day, we can expand the rest of the day's counts by the percent of time the sonar was operational, so that day will not be "missing" at the day time-scale, although those three hours still are if we are operating on an hour time-scale. 

```{r oper-fig, fig.cap = "Purple depicts hours when the sonar was working, while yellow indicates the sonar was not functioning."}
hr_periods %>%
  mutate(hr = as.numeric(hour) / (60*60)) %>%
  mutate(date = as.Date(paste(month(date), mday(date)), format = "%m %d")) %>%
  ggplot(aes(x = date,
             y = hr,
             color = operational,
             fill = operational)) +
  geom_tile() +
  scale_fill_viridis_d(direction = -1,
                       name = "Sonar\nOperational") +
  scale_color_viridis_d(direction = -1,
                        name = "Sonar\nOperational") +
  facet_wrap(~ year,
             scales = "fixed") +
  scale_x_date(breaks = breaks_pretty(7)) +
  labs(x = "Date",
       y = "Hour") +
  theme(legend.position = "bottom")
```

```{r miss-ts, fig.height = 6, fig.cap = "Time series of upstream fish in blue, with missing data highlighted in red."}
p_list = vector("list",
                length = nrow(ts_est))
for(i in seq_along(ts_est$time_scale)) {
  p_list[[i]] <- ggplot_na_distribution(ts_est$ts_zoo[[i]]) +
    labs(title = paste(ts_est$time_scale[i], "in", ts_est$year[i]),
         subtitle = str_to_title(ts_est$direction[i])) +
    theme(axis.title.y = element_blank())
}
ggarrange(plotlist = p_list,
          ncol = 2,
          nrow = 4,
          common.legend = T,
          legend = "bottom")
```

After interpolating across the missing data, Table \@ref(tab:missing-tab) displays how many fish were added to each year's estimate, based on the temporal scale and the interpolation method. Table \@ref(tab:abund-est-missing) provides final estimates of total net upstream steelhead each year, including fish smaller than 67 cm and periods of missing data, split out by the temporal scale the data was summarized on. 

```{r missing-tab}
all_preds %>%
  group_by(time_scale,
           direction,
           year,
           model) %>%
  summarize(pred_tot = sum(total, na.rm = T),
            pred_se = sqrt(sum(se^2, na.rm = T)),
            .groups = "drop") %>%
  # group_by(time_scale,
  #          direction,
  #          year) |> 
  # mutate(pred_tot = pred_tot + pred_tot[is.na(model)],
  #        pred_se = sqrt(pred_se^2 + pred_se[is.na(model)]^2)) |> 
  filter(!is.na(model)) |> 
  pivot_wider(names_from = direction,
              values_from = starts_with("pred")) |> 
  mutate(pred_tot = pred_tot_up - pred_tot_down,
         pred_se = msm::deltamethod(~ x1 - x2,
                                    mean = c(pred_tot_up,
                                             pred_tot_down),
                                    cov = diag(c(pred_se_up,
                                                 pred_se_down)^2))) |> 
  select(-ends_with("down"),
         -ends_with("up")) |> 
  mutate(prnt_value = paste0(round(pred_tot), " (", round(pred_se, 1), ")")) %>%
  select(-starts_with("pred_")) %>%
  pivot_wider(names_from = "model",
              values_from = prnt_value) %>%
  right_join(expand(all_preds,
                    time_scale, year)) %>%
  arrange(year,
          time_scale) %>%
  kable(col.names = c("Time Scale",
                      "Year",
                      "Kalman",
                      "Linear",
                      "MA"),
        booktabs = T,
        linesep = "",
        caption = "Estimates (SE) of how many net upstream steelhead are added to the totals from periods with wholly missing data. Interpolation methods include the Kalman filter, linear model, and moving average. There are three estimates per year, corresponding to the three different temporal scales. Blank cells indicate no interpolation was necessary for that year / temporal scale combination.") %>%
  kable_styling() %>%
  row_spec(row = c(3, 6),
           hline_after = T)
```


```{r abund-est-missing}
all_preds %>%
  filter(is.na(model)) |> 
  group_by(time_scale,
           direction,
           year) %>%
  summarize(obs_tot = sum(total, na.rm = T),
            obs_se = sqrt(sum(se^2, na.rm = T)),
            .groups = "drop") %>%
  full_join(all_preds %>%
              filter(!is.na(model)) %>%
              group_by(time_scale,
                       direction,
                       year,
                       model) %>%
              summarize(pred_tot = sum(total, na.rm = T),
                        pred_se = sqrt(sum(se^2, na.rm = T)),
                        .groups = "drop"),
            multiple = "all") %>%
  mutate(total = obs_tot + pred_tot,
         se = sqrt(obs_se^2 + pred_se^2)) %>%
  mutate(none = paste0(round(obs_tot), " (", round(obs_se, 1), ")"),
         prnt_value = paste0(round(total), " (", round(se, 1), ")")) %>%
  select(-starts_with("obs"),
         -starts_with("pred")) %>%
  select(-total, -se) %>%
  pivot_wider(names_from = "model",
              values_from = prnt_value) %>%
  # select(-none) %>%
  arrange(year,
          direction,
          time_scale) %>%
  mutate(across(direction,
                str_to_title)) |> 
  kable(col.names = c("Time Scale",
                      "Direction",
                      "Year",
                      "None",
                      "Kalman",
                      "Linear",
                      "MA"),
        booktabs = T,
        linesep = "",
        caption = "Estimates (SE) of total steelhead by direction and year, using only extremely confident observations, and after interpolating counts for periods of missing data. Interpolation methods include no interpolation, the Kalman filter, linear model, and moving average. There are three estimates per year, corresponding to the three different temporal scales.") %>%
  kable_styling() #%>%
  # row_spec(row = c(3, 6),
  #          hline_after = T)

```

\newpage
# Discussion Points

* What to do with rows where `data_recorded ` is "Partial"? This includes `r sum(sonar_raw$data_recorded  == "Partial")` rows, or `r round(sum(sonar_raw$data_recorded  == "Partial") / nrow(sonar_raw) * 100, 1)`% of the data. Exclude and treat as missing data? Or is there a better way to parse this? Currently I've filtered it out and treated it as missing.
* What should we do with observations with confidence of 2 or 3? They are currently excluded completely.
* What to do about kelts?

## Expanding 30 min to 60 min

* The regression between counts in the first hour and the entire hour shows a consistent expectation that the counts in the second part of the hour will be less than counts in the first part. This holds regardless of whether we aggregate data by hour, day or something in between. 
* Currently I'm calculating the net upstream totals for each half hour period before running the regressions. If there's a compelling reason to either run separate regressions for downstream and upstream moving fish, or treat downstream and upstream fish from the same hour as two distinct data points, let's talk about that.
* We could run separate regressions for each year, but if the methodology is the same year-to-year, I don't see why we'd expect different results.
* Three years is not enough to use year as a random effect, but perhaps in a few more years we could explore this as an option.

## Excluding Bull Trout

* Should we assume any fish smaller than 40 cm is a bull trout, since that was the smallest steelhead length recorded? Under the current method, this doesn't matter because any fish smaller than `r round(min(pred_tab$length[pred_tab$prob_sthd >= 0.5]), 1)` cm is excluded from the steelhead counts regardless of date of capture.

<!-- * Incorporating some kind of spline or curve to account for steelhead run timing could improve this model. For example a 55 cm long fish might be considered a non-steelhead early or late in the season, but could be predicted to be a steelhead in the middle of the run, because it may be more likely that any fish is a steelhead then. To fit this model, I'll need the date when each fish's length was taken as part of the species composition data. -->

* I updated this model to include both the Julian day of capture and the fish length, using a spline for both covariates. The fish length spline turned out to be pretty close to a straight line, with larger fish being more likely to be a steelhead. The Julian day of capture had a peak probability of being a steelhead occurring in mid- to late-March, and tapering off on either side. Given there were a number of bull trout caught in the very beginning and towards the end of the sampling period, this shape makes sense. However, it should be noted that including Julian day of capture reduced the estimated number of small steelhead (less than 67 cm) in all years. It was a small reduction in 2020 and 2021, but a substantial one in 2019. This appears to be because there were a large number of small fish detected late in the run in 2019. Because they were so late, virtually
none of those fish were predicted to be steelhead using this updated model.

## Missing Data

* Any of the interpolation models we tested (Kalman filter, linear regression or moving average) resulted in larger estimates of steelhead moving upstream (Table \@ref(tab:abund-est-missing)), but differed in which one provide the biggest increase depending on the time-scale and year.
* The uncertainty (e.g. standard error) grew when incorporating those missing data, which is appropriate. The uncertainty grew substantially in 2020, when there was a large period of missing data due to COVID restrictions.
* Depending on how big the missing data gaps are, and the time-scale we are aggregating data on, there were some years and time-scales with no missing data (e.g. 24 hour scale in 2021). The lack of missing data relies on using the percentage of hours when sonar was operational within each time-step to increase the estimates for any time-steps when the operational time was less than 100%.
* The alternative to expanding time-steps when the sonar was partially operational is to remove all data from those time-steps and treat them as missing data. 
* It's unclear to me whether that would have a substantial impact on the overall estimates or uncertainty.

